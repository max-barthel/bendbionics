name: Docker Deployment to Hetzner VPS

on:
    workflow_run:
        workflows: ["Web Application CI/CD"]
        types:
            - completed
        branches: [main, web-app-deployment]
    workflow_dispatch:
        inputs:
            skip_build:
                description: "Skip build step (use existing images)"
                required: false
                default: false
                type: boolean
            skip_tests:
                description: "Skip running tests"
                required: false
                default: false
                type: boolean
            skip_deploy:
                description: "Skip deploy step"
                required: false
                default: false
                type: boolean

env:
    BUN_VERSION: "latest"
    PYTHON_VERSION: "3.11"
    CI: "true"
    HUSKY: "0" # Suppress git hooks in CI
    # Docker registry configuration
    DOCKER_REGISTRY: ghcr.io
    DOCKER_IMAGE_PREFIX: ${{ github.repository_owner }}/bendbionics
    VERSION: ${{ github.event.workflow_run.head_sha || github.sha }}
    # Server configuration
    SERVER_USER: "root"
    SERVER_HOST: ${{ secrets.SERVER_HOST }}
    SERVER_PATH: "/opt/bendbionics"

jobs:
    # Docker deployment workflow
    deploy:
        name: üê≥ Docker Deployment to VPS
        runs-on: ubuntu-latest
        if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
        environment: production
        permissions:
            contents: read
            packages: write
        services:
            postgres:
                image: postgres:15
                env:
                    POSTGRES_USER: postgres
                    POSTGRES_PASSWORD: postgres
                    POSTGRES_DB: bendbionics_test
                options: >-
                    --health-cmd pg_isready
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
                ports:
                    - 5432:5432
        steps:
            - name: üéØ Checkout code
              uses: actions/checkout@v6
              with:
                  ref: ${{ github.event.workflow_run.head_sha || github.sha }}

            - name: üîß Setup Bun
              uses: oven-sh/setup-bun@v2
              with:
                  bun-version: ${{ env.BUN_VERSION }}

            - name: üíæ Cache Bun dependencies
              uses: actions/cache@v4
              with:
                  path: |
                      frontend/node_modules
                      ~/.bun/install/cache
                  key: ${{ runner.os }}-bun-${{ hashFiles('frontend/bun.lock') }}
                  restore-keys: |
                      ${{ runner.os }}-bun-

            - name: üêç Setup Python
              uses: actions/setup-python@v6
              with:
                  python-version: ${{ env.PYTHON_VERSION }}

            - name: Install uv
              uses: astral-sh/setup-uv@v7
              with:
                  version: "latest"

            - name: üì¶ Install dependencies
              if: ${{ !inputs.skip_tests }}
              run: |
                  cd frontend && bun install
                  cd ../backend && uv sync

            - name: üß™ Run frontend tests
              if: ${{ !inputs.skip_tests && !inputs.skip_build }}
              run: |
                  cd frontend && bun run test:run

            - name: üóÑÔ∏è Setup test database
              if: ${{ !inputs.skip_tests && !inputs.skip_build }}
              env:
                  POSTGRES_USER: postgres
                  POSTGRES_PASSWORD: postgres
                  POSTGRES_HOST: localhost
                  POSTGRES_PORT: 5432
                  POSTGRES_DB: bendbionics_test
              run: |
                  # Install PostgreSQL client tools
                  sudo apt-get update && sudo apt-get install -y postgresql-client

                  # Wait for PostgreSQL to be ready
                  until pg_isready -h localhost -p 5432 -U postgres; do
                      echo "Waiting for PostgreSQL..."
                      sleep 1
                  done
                  echo "‚úÖ PostgreSQL is ready"

                  # Set TEST_DATABASE_URL for pytest
                  echo "TEST_DATABASE_URL=postgresql://postgres:postgres@localhost:5432/bendbionics_test" >> $GITHUB_ENV

            - name: üß™ Run backend tests
              if: ${{ !inputs.skip_tests && !inputs.skip_build }}
              env:
                  TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/bendbionics_test
              run: |
                  cd backend && uv run pytest tests/ -v

            - name: üîê Login to GitHub Container Registry
              if: ${{ !inputs.skip_build }}
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.DOCKER_REGISTRY }}
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            - name: üèóÔ∏è Set up Docker Buildx
              if: ${{ !inputs.skip_build }}
              uses: docker/setup-buildx-action@v3

            - name: üèóÔ∏è Build and push Docker images
              if: ${{ !inputs.skip_build }}
              run: |
                  set -e
                  echo "üèóÔ∏è Building Docker images..."

                  # Build backend image
                  docker buildx build --platform linux/amd64 \
                      --tag "${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_PREFIX }}-backend:${{ env.VERSION }}" \
                      --tag "${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_PREFIX }}-backend:latest" \
                      --push \
                      ./backend || {
                      echo "‚ùå Backend image build failed"
                      exit 1
                  }

                  # Build frontend image
                  docker buildx build --platform linux/amd64 \
                      --tag "${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_PREFIX }}-frontend:${{ env.VERSION }}" \
                      --tag "${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_PREFIX }}-frontend:latest" \
                      --push \
                      ./frontend || {
                      echo "‚ùå Frontend image build failed"
                      exit 1
                  }

                  # Build nginx image
                  docker buildx build --platform linux/amd64 \
                      --tag "${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_PREFIX }}-nginx:${{ env.VERSION }}" \
                      --tag "${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_PREFIX }}-nginx:latest" \
                      --push \
                      ./docker/nginx || {
                      echo "‚ùå Nginx image build failed"
                      exit 1
                  }

                  echo "‚úÖ All images built and pushed successfully"

            - name: üîç Validate server configuration
              if: ${{ !inputs.skip_deploy }}
              run: |
                  echo "üîç Validating server configuration..."

                  # Check if SERVER_HOST secret is set
                  if [ -z "${{ secrets.SERVER_HOST }}" ]; then
                      echo "‚ùå SERVER_HOST secret is not set"
                      echo "   Please add SERVER_HOST to your GitHub repository secrets"
                      exit 1
                  fi

                  # Check if SSH_PRIVATE_KEY secret is set
                  if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
                      echo "‚ùå SSH_PRIVATE_KEY secret is not set"
                      echo "   Please add SSH_PRIVATE_KEY to your GitHub repository secrets"
                      exit 1
                  fi

                  echo "‚úÖ Server configuration validation passed"
                  echo "   Server Host: ${{ secrets.SERVER_HOST }}"

            - name: üîë Setup SSH
              if: ${{ !inputs.skip_deploy }}
              uses: webfactory/ssh-agent@v0.9.1
              with:
                  ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

            - name: üîê Configure SSH known hosts
              if: ${{ !inputs.skip_deploy }}
              run: |
                  echo "üîê Configuring SSH known hosts..."
                  mkdir -p ~/.ssh
                  chmod 700 ~/.ssh
                  ssh-keyscan -H "${{ env.SERVER_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null
                  chmod 600 ~/.ssh/known_hosts
                  echo "‚úÖ SSH known hosts configured"

            - name: üì§ Upload Docker Compose files to VPS
              if: ${{ !inputs.skip_deploy }}
              run: |
                  echo "üì§ Uploading Docker Compose files to VPS..."

                  # Create directory structure on VPS
                  ssh "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}" "mkdir -p ${{ env.SERVER_PATH }}/docker"

                  # Upload docker-compose files
                  scp docker-compose.yml "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.SERVER_PATH }}/"
                  scp docker-compose.prod.yml "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.SERVER_PATH }}/"

                  # Upload deploy script and shared library
                  scp scripts/docker/deploy-vps.sh "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.SERVER_PATH }}/"
                  scp scripts/lib.sh "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.SERVER_PATH }}/"
                  ssh "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}" "chmod +x ${{ env.SERVER_PATH }}/deploy-vps.sh"

                  echo "‚úÖ Files uploaded successfully"

            - name: üöÄ Deploy on VPS
              if: ${{ !inputs.skip_deploy }}
              run: |
                  echo "üöÄ Deploying on VPS..."

                  # Set environment variables for deployment
                  ssh "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}" "
                      cd ${{ env.SERVER_PATH }}
                      export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
                      export DOCKER_IMAGE_PREFIX=${{ env.DOCKER_IMAGE_PREFIX }}
                      export VERSION=${{ env.VERSION }}
                      ./deploy-vps.sh
                  "

                  echo "‚úÖ Deployment completed"

            - name: üîí Setup SSL certificates
              if: ${{ !inputs.skip_deploy }}
              env:
                  DOMAIN: ${{ secrets.DOMAIN }}
                  DOMAIN_EMAIL: ${{ secrets.DOMAIN_EMAIL }}
              run: |
                  # Use defaults if secrets are not set
                  DOMAIN="${DOMAIN:-bendbionics.com}"
                  DOMAIN_EMAIL="${DOMAIN_EMAIL:-noreply@bendbionics.com}"
                  echo "üîí Checking SSL certificate status..."

                  # Check if certificates already exist
                  CERT_EXISTS=$(ssh "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}" "
                      cd ${{ env.SERVER_PATH }}
                      docker compose -f docker-compose.yml exec -T nginx test -f /etc/nginx/ssl/certs/fullchain.pem 2>/dev/null && echo 'yes' || echo 'no'
                  " || echo "no")

                  if [ "$CERT_EXISTS" = "yes" ]; then
                      echo "‚úÖ SSL certificates already exist, skipping acquisition"
                      exit 0
                  fi

                  echo "üìú SSL certificates not found, attempting to obtain..."
                  echo "üìß Using domain: $DOMAIN"
                  echo "üìß Using email: $DOMAIN_EMAIL"

                  # Attempt to obtain certificates
                  # This will fail gracefully if domain is not ready or rate limited
                  ssh "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}" "
                      cd ${{ env.SERVER_PATH }}

                      # Wait a moment for nginx to be fully ready
                      sleep 5

                      # Attempt to obtain certificate using webroot method
                      if docker compose -f docker-compose.yml run --rm certbot certonly \\
                          --webroot \\
                          -w /var/www/certbot \\
                          -d $DOMAIN \\
                          --email $DOMAIN_EMAIL \\
                          --agree-tos \\
                          --non-interactive \\
                          --keep-until-expiring 2>&1; then

                          echo '‚úÖ SSL certificates obtained successfully'

                          # Restart nginx to pick up SSL configuration
                          echo 'üîÑ Restarting nginx to enable HTTPS...'
                          docker compose -f docker-compose.yml restart nginx

                          # Wait for nginx to restart
                          sleep 5

                          echo '‚úÖ HTTPS should now be enabled'
                      else
                          echo '‚ö†Ô∏è  Failed to obtain SSL certificates (domain may not be ready or rate limited)'
                          echo '‚ö†Ô∏è  Application will continue running in HTTP-only mode'
                          echo '‚ö†Ô∏è  You can manually obtain certificates later with:'
                          echo \"‚ö†Ô∏è  docker compose -f docker-compose.yml run --rm certbot certonly --webroot -w /var/www/certbot -d $DOMAIN --email $DOMAIN_EMAIL --agree-tos --non-interactive\"
                      fi
                  " || {
                      echo "‚ö†Ô∏è  SSL certificate acquisition failed or skipped"
                      echo "‚ö†Ô∏è  Application will continue in HTTP-only mode"
                  }

            - name: üè• Health check
              if: ${{ !inputs.skip_deploy }}
              run: |
                  echo "üè• Checking application health..."
                  MAX_ATTEMPTS=12
                  ATTEMPT=0
                  SLEEP_INTERVAL=5

                  while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                      # Try HTTP first (works even without SSL certificates)
                      if curl -f -s http://bendbionics.com/health > /dev/null 2>&1; then
                          echo "‚úÖ Health check passed (HTTP)!"
                          exit 0
                      fi

                      # Try HTTPS as fallback (if SSL certificates are available)
                      if curl -f -s https://bendbionics.com/health > /dev/null 2>&1; then
                          echo "‚úÖ Health check passed (HTTPS)!"
                          exit 0
                      fi

                      ATTEMPT=$((ATTEMPT + 1))
                      if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                          echo "‚è≥ Attempt $ATTEMPT/$MAX_ATTEMPTS failed, retrying in ${SLEEP_INTERVAL}s..."
                          sleep $SLEEP_INTERVAL
                      fi
                  done

                  echo "‚ùå Health check failed after $MAX_ATTEMPTS attempts"
                  exit 1

            - name: üîç Verify deployment
              if: ${{ !inputs.skip_deploy }}
              run: |
                  echo "üîç Verifying deployment..."
                  ssh "${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}" "
                      echo 'üìä Docker Services Status:'
                      cd ${{ env.SERVER_PATH }}
                      docker compose -f docker-compose.yml ps

                      echo ''
                      echo 'üíæ Disk Usage:'
                      df -h / | tail -1
                  "

                  echo "‚úÖ Deployment verification completed"

            - name: üéâ Deployment Results
              if: success()
              run: |
                  echo "üéâ Docker Deployment Complete!"
                  echo ""
                  echo "üê≥ Images pushed to: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_PREFIX }}"
                  echo "üåê Application: https://bendbionics.com"
                  echo "üìö API Documentation: https://bendbionics.com/docs"
                  echo "üè• Health Check: https://bendbionics.com/health"
                  echo ""
                  echo "üîß Useful Commands:"
                  echo "View logs: ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} 'cd ${{ env.SERVER_PATH }} && docker compose -f docker-compose.yml logs -f'"
                  echo "Restart services: ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} 'cd ${{ env.SERVER_PATH }} && docker compose -f docker-compose.yml restart'"
